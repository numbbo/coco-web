---
title: Getting started with COCO
---

The COCO framework is divided into two parts:

1. Running an algorithm on a COCO benchmark suite and thereby collecting performance data for this algorithm
2. Displaying COCO results via the postprocessing, in particular comparing algorithms from or with the [data archive](/data-archive).

If you're only here to analyse and compare existing algorithms or COCO benchmark data, you can skip straight to [step 2](#step-2-analysing-and-comparing-results-postprocessing).


## Step 1: Benchmarking an algorithm (collecting data)

We use the [`cocoex`](https://pypi.org/project/cocoex) Python module to benchmark an algorithm.
For using different languages see [here](https://github.com/numbbo/coco).

### Installation (assuming Python is present)
From a system shell, execute

```sh
pip install cocoex cocopp
```

### Using [`cocoex`](https://numbbo.github.io/gforge/apidocs-cocoex)
Depending on the algorithm, we have to chose the appropriate benchmark suite

```python
>>> import cocoex

>>> cocoex.known_suite_names
['bbob',
 'bbob-biobj',
 'bbob-biobj-ext',
 'bbob-constrained',
 'bbob-largescale',
 'bbob-mixint',
 'bbob-biobj-mixint']
```

see also [here](https://numbbo.github.io/coco/testsuites).

A [short-ish example code](https://github.com/numbbo/coco/blob/development/code-experiments/build/python/example/example_experiment_for_beginners.py) that benchmarks [`scipy.optimize.fmin`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin.html) on the [`bbob`](https://numbbo.github.io/coco/testsuites/bbob) suite looks like this:


```python
import cocoex, cocopp  # experimentation and post-processing modules
import scipy.optimize  # to define the solver to be benchmarked
from numpy.random import rand  # for randomised restarts

### input
suite_name = "bbob"
output_folder = "scipy-optimize-fmin"
fmin = scipy.optimize.fmin
budget_multiplier = 1.1  # increase to 10, 100, ...

### prepare
suite = cocoex.Suite(suite_name, "", "")
observer = cocoex.Observer(suite_name, "result_folder: " + output_folder)
minimal_print = cocoex.utilities.MiniPrint()

### go
for problem in suite:  # this loop will take 2-3 minutes
    problem.observe_with(observer)  # generates the data for cocopp post-processing
    # apply restarts while neither the problem is solved nor the budget is exhausted
    while (problem.evaluations < problem.dimension * budget_multiplier
           and not problem.final_target_hit):
        observer.signal_restart(problem)
        xopt = fmin(problem, problem.initial_solution_proposal(), disp=False)
        problem(xopt)  # make sure the returned solution is evaluated
    minimal_print(problem, final=problem.index == len(suite) - 1)

### post-process data
cocopp.main(observer.result_folder + ' bfgs!');  # re-run folders look like "...-001" etc
```
The benchmarking data are written to a subfolder in the `exdata` folder.
The last line postprocesses the obtained data and compares the result with BFGS.
The resulting figures and tables can be browsed via `ppdata/index.html`.

For benchmarking another algorithm, `fmin` has to be assigned respectively and its calling code `fmin(problem, ...)` needs to be adapted.
For example, some algorithms may need the maximal budget, `problem.dimension * budget_multiplier` as input parameter.

## Step 2: Analysing and comparing results (postprocessing)

Benchmarking performance results are displayed with the [`cocopp`](https://pypi.org/project/cocopp) Python module and a web browser.

### Installation (assuming Python is present)

From a system shell, execute

```sh
pip install cocopp
```

### Usage

The [`cocopp`](https://pypi.org/project/cocopp) "postprocessing" allows basic usage in a system shell:

```sh
python -m cocopp name_1 [name_2 [name_3 [... ]]]
```

creates a couple of hundred figures and (after some seconds) displays the page `ppdata/index.html` with the default browser.
The arguments `name_1`, `name_2`,... (`[]`-braces indicate optional arguments) are either local folders containing COCO data from a single benchmarked algorithm (typically like `exdata/algorithm_name`) or names of benchmarked algorithms from the [COCO data archive](https://numbbo.github.io/data-archive) (see below).

The recommended usage is however from an `ipython` shell or a Jupyter notebook via the [`cocopp.main`](https://numbbo.github.io/gforge/apidocs-cocopp/cocopp.rungeneric.html#main) method.

```python
>>> import cocopp

>>> cocopp.main('name_1 [name_2 [name_3 ...]]')
```
gives the same result as the above.

#### Finding data to compare with
Hundreds of COCO comparative data sets are provided online and can be listed, filtered, and retrieved via [`cocopp.archives`](https://numbbo.github.io/gforge/apidocs-cocopp/cocopp.archiving.OfficialArchives.html) and processed alone or together with local data.
For example

```python
>>> cocopp.archives.bbob('bfgs')  # list COCO data of bfgs on the bbob suite

['2009/BFGS_ros_noiseless.tgz',
 '2012/DE-BFGS_voglis_noiseless.tgz',
 '2012/PSO-BFGS_voglis_noiseless.tgz',
 '2014-others/BFGS-scipy_Baudis.tgz',
 '2014-others/L-BFGS-B-scipy_Baudis.tgz',
 '2018/BFGS-M-17_Blelly.tgz',
 '2018/BFGS-P-09_Blelly.tgz',
 '2018/BFGS-P-Instances_Blelly.tgz',
 '2018/BFGS-P-StPt_Blelly.tgz',
 '2018/BFGS-P-range_Blelly.tgz',
 '2019/BFGS-scipy-2019_Varelas.tgz',
 '2019/L-BFGS-B-scipy-2019_Varelas.tgz']
 ```

lists all data sets run on the `bbob` testbed containing `'bfgs'` in their name.
The first three in the list can be postprocessed like

```python
>>> dsl = cocopp.main('bfgs! 12/DE-BFGS 12/PSO-BFGS')  # "!" picks the first match only
```

Separated by spaces, each string must give a single unique match. Otherwise, an (informative) `ValueError` is raised.
This call creates figures, modifies and open `ppdata/index.html` in a browser, and also returns a data set list of all read-in data.
To display all BFGS data from the `bbob` suite, we use regular expression syntax,

```python
>>> dsl = cocopp.main('bbob/.*bfgs')
```

where `.*` matches any character any number of times (including zero) and the expression must match the beginning of the archive entry name.

As a special case, a trailing `*` indicates all names _containing_ the preceding substring.
The output figures of

```python
>>> dsl = cocopp.main('bob/2009/*')  # may take some more time when these data are downloaded
```

contains 31 algorithms and can be browsed at [https://numbbo.github.io/ppdata-archive/bbob/2009](https://numbbo.github.io/ppdata-archive/bbob/2009).
To display algorithms in the background, the `cocopp.genericsettings.background` variable needs to be set:

```python
>>> cocopp.genericsettings.background = {None: cocopp.archives.bbob.get_all('2009/*')}  # may take some time when these data are downloaded
```
where [`None`](http://docs.python.org/library/constants.html#None) invokes the default color and line style (solid grey, `cocopp.genericsettings.background_default_style`).

Finally, we can, for example, compare our own data with the first `'bfgs'`-matching archived algorithm, while all other COCO data from 2009 (on the `bbob` suite) are shown in the background:

```python
>>> dsl = cocopp.main('exdata/my_data bfgs!')
```
